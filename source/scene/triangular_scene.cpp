//// Created by Caio W on 3/2/22.//#include "triangular_scene.hpp"#include <unordered_set>#include <util/gltf.hpp>#include <tinyobjloader/tinyobjloader.h>#include <tinygltf/tinygltf.h>#include <glm/gtx/quaternion.hpp>#include <fmt/core.h>#include <util/gltf.hpp>#include <embree3/rtcore.h>namespace {	bool intersect_triangle					(cr::ray       ray,  /* ray for the intersection */					 glm::vec3      v0,   /* vertex 0 */					 glm::vec3      v1,   /* vertex 1 */					 glm::vec3      v2,   /* vertex 2 */					 float     mint, /* lower bound for t */					 float     maxt, /* upper bound for t */					 glm::vec3 &normal,					 glm::vec2 &uv,					 float &distance)	{		auto A = glm::mat3(ray.direction, v1-v0, v2-v0);		auto sol =  glm::vec3(inverse(A) * (ray.origin - v0));		float t = -sol.x;		float u = sol.y;		float v = sol.z;		bool isect = mint<t && t<maxt && 0<u && 0<v && u+v<1;		distance = sol.x;		normal = normalize(cross(A[1],A[2]));		uv = glm::vec2(u,v);		return isect;	}}void cr::triangular_scene::_load_glb(const std::filesystem::path &path) {	using namespace tinygltf;	Model model;	TinyGLTF loader;	std::string err;	std::string warn;	const auto ret = loader.LoadBinaryFromFile(&model, &err, &warn, path);	auto visited_nodes = std::unordered_set<uint64_t>();	auto vertices = std::vector<glm::vec3>();	auto normals = std::vector<glm::vec3>();	auto texcoords = std::vector<glm::vec2>();	auto indices = std::vector<uint32_t>();	auto materials = std::vector<uint32_t>();	// Need to be able to pass it in, so need to pre-declare	auto traverse = std::function<void(int32_t node_idx, const glm::mat4 &parent)>();	traverse = [&visited_nodes, &model, &vertices, &texcoords, &normals, &indices, &materials, &traverse](int32_t node_idx, const glm::mat4 &parent) {		visited_nodes.insert(node_idx);		const auto &node = model.nodes[node_idx];		const auto transform = parent * gltf::get_transformation(node);		if (node.mesh != -1) {			const auto loaded_node = gltf::get_vertices(model, node, transform);			indices.reserve(indices.size() + loaded_node.indices.size());			for (auto idx : loaded_node.indices)				indices.push_back(idx + vertices.size());			texcoords.reserve(texcoords.size() + loaded_node.texcoords.size());			for (auto texcoord : loaded_node.texcoords)				texcoords.push_back(texcoord);			vertices.reserve(vertices.size() + loaded_node.vertices.size());			for (auto vertex : loaded_node.vertices)				vertices.push_back(vertex);			normals.reserve(normals.size() + loaded_node.normals.size());			for (auto normal : loaded_node.normals)				normals.push_back(normal);			materials.reserve(materials.size() + loaded_node.material_indices.size());			for (auto material : loaded_node.material_indices)				materials.push_back(material);		}		for (auto child : node.children)			traverse(child, transform);	};	if (!warn.empty()) {		printf("Warn: %s\n", warn.c_str());	}	if (!err.empty()) {		printf("Err: %s\n", err.c_str());	}	if (!ret) {		printf("Failed to parse glTF\n");		exit(-1);	}	for (size_t i = 0; i < model.nodes.size(); i++)	{		fmt::print("loading node {}\n", model.nodes[i].name);		// Make sure we haven't visited this node before		if (visited_nodes.contains(i))			continue;		else			visited_nodes.insert(i);		auto matrix = glm::mat4(1.0f);		traverse(i, matrix);	}	// Transform the vertices into float vector	_vertices.reserve(vertices.size() * 3);	for (auto vertex : vertices)	{		_vertices.push_back(vertex.x);		_vertices.push_back(vertex.y);		_vertices.push_back(vertex.z);	}	_normals.reserve(normals.size() * 3);	for (auto normal : normals)	{		_normals.push_back(normal.x);		_normals.push_back(normal.y);		_normals.push_back(normal.z);	}	_texcoords.reserve(texcoords.size() * 2);	for (auto texcoord : texcoords)	{		_texcoords.push_back(texcoord.x);		_texcoords.push_back(texcoord.y);	}	std::swap(_indices, indices);	std::swap(_material_indices, materials);	const auto material_count = *std::max_element(_material_indices.begin(), _material_indices.end()) + 1;	for (size_t i = 0; i < material_count; i++)	{		fmt::print("new material: name {}\n", model.materials[i].name);		auto mat = gltf::load_material(&model.materials[i], model.textures, model.images, model.samplers);		_materials.push_back(std::move(mat));	}}void cr::triangular_scene::_load_model(const std::filesystem::path &path) {	auto reader_config = tinyobj::ObjReaderConfig();	reader_config.mtl_search_path = "./";	reader_config.triangulate = true;	auto reader = tinyobj::ObjReader();	if (!reader.ParseFromFile(path.generic_string(), reader_config)) {		if (!reader.Error().empty()) {			fmt::print("TinyObjReader: {}", reader.Error().c_str());		}		exit(1);	}	if (!reader.Warning().empty()) {		fmt::print("TinyObjReader: {}", reader.Warning().c_str());	}	const auto &attrib = reader.GetAttrib();	const auto &shapes = reader.GetShapes();	_vertices = attrib.vertices;	for (const auto &shape: shapes) {		_indices.reserve(_vertices.size() + shape.mesh.indices.size());		for (auto idx: shape.mesh.indices)			_indices.push_back(idx.vertex_index);		_material_indices.reserve(_material_indices.size() + shape.mesh.material_ids.size());		for (auto idx: shape.mesh.material_ids)			_material_indices.push_back(0);	}	const auto &materials = reader.GetMaterials();	for (const auto &mat: materials) {//		auto diffuse = std::make_unique<cr::diffuse>(glm::vec3(0.0f), glm::vec3(1.0f, 1.0f, 1.0f));//		_materials.push_back(std::move(diffuse));	}}cr::triangular_scene::triangular_scene(const std::filesystem::path &path) {	_device = rtcNewDevice(nullptr);	_scene = rtcNewScene(_device);	_geom = rtcNewGeometry(_device, RTC_GEOMETRY_TYPE_TRIANGLE);	_load_glb(path);//	_load_model(path);	const auto vertex_buffer = static_cast<float *>(rtcSetNewGeometryBuffer(_geom,																																					RTC_BUFFER_TYPE_VERTEX, 0, RTC_FORMAT_FLOAT3,																																					3 * sizeof(float), _vertices.size() / 3));	const auto index_buffer = static_cast<uint32_t *>(rtcSetNewGeometryBuffer(_geom,																																						RTC_BUFFER_TYPE_INDEX, 0, RTC_FORMAT_UINT3,																																						3 * sizeof(uint32_t),																																						_indices.size() / 3));	rtcSetGeometryVertexAttributeCount(_geom,3);	const auto texcoord_buffer = static_cast<uint32_t *>(rtcSetNewGeometryBuffer(_geom,																																										 RTC_BUFFER_TYPE_VERTEX_ATTRIBUTE,																																										 0, RTC_FORMAT_FLOAT2,																																										 2 * sizeof(float),																																										 _texcoords.size() / 2));	const auto material_index_buffer = static_cast<uint32_t *>(rtcSetNewGeometryBuffer(_geom,																																										 RTC_BUFFER_TYPE_VERTEX_ATTRIBUTE,																																										 1, RTC_FORMAT_FLOAT,																																										 1 * sizeof(float),																																										 _material_indices.size()));	const auto normal_buffer = static_cast<uint32_t *>(rtcSetNewGeometryBuffer(_geom,																																										 RTC_BUFFER_TYPE_VERTEX_ATTRIBUTE,																																										 2, RTC_FORMAT_FLOAT3,																																										 3 * sizeof(float),																																										 _normals.size() / 3));	std::memcpy(texcoord_buffer, _texcoords.data(), _texcoords.size() * sizeof(float));	std::memcpy(vertex_buffer, _vertices.data(), _vertices.size() * sizeof(float));	std::memcpy(index_buffer, _indices.data(), _indices.size() * sizeof(uint32_t));	std::memcpy(normal_buffer, _normals.data(), _normals.size() * sizeof(float));	auto material_indices_as_floats = std::vector<float>();	material_indices_as_floats.reserve(_material_indices.size());	for (auto index : _material_indices)		material_indices_as_floats.push_back(static_cast<float>(index));	std::memcpy(material_index_buffer, material_indices_as_floats.data(), material_indices_as_floats.size() * sizeof(uint32_t));	rtcCommitGeometry(_geom);	rtcAttachGeometry(_scene, _geom);	rtcReleaseGeometry(_geom);	rtcCommitScene(_scene);}std::optional<cr::intersection> cr::triangular_scene::intersect(const cr::ray &ray) {#define EMBREE#ifdef EMBREE	auto rayhit = RTCRayHit();	rayhit.ray.org_x = ray.origin.x;	rayhit.ray.org_y = ray.origin.y;	rayhit.ray.org_z = ray.origin.z;	rayhit.ray.dir_x = ray.direction.x;	rayhit.ray.dir_y = ray.direction.y;	rayhit.ray.dir_z = ray.direction.z;	rayhit.ray.tnear = 0.0;	rayhit.ray.tfar = std::numeric_limits<float>::infinity();	rayhit.hit.geomID = RTC_INVALID_GEOMETRY_ID;	auto context = RTCIntersectContext();	rtcInitIntersectContext(&context);	rtcIntersect1(_scene, &context, &rayhit);	if (rayhit.hit.geomID != RTC_INVALID_GEOMETRY_ID) {		auto intersection = cr::intersection();		intersection.distance = rayhit.ray.tfar;		intersection.id = rayhit.hit.primID;		intersection.normal = glm::normalize(glm::vec3(rayhit.hit.Ng_x, rayhit.hit.Ng_y, rayhit.hit.Ng_z));		if (glm::dot(intersection.normal, ray.direction) > 0)			intersection.normal *= -1.0f;		rtcInterpolate0(						_geom,						rayhit.hit.primID,						rayhit.hit.u,						rayhit.hit.v,						RTC_BUFFER_TYPE_VERTEX_ATTRIBUTE,						0,						reinterpret_cast<float *>(&intersection.texcoord),						2);		intersection.material = _materials[_material_indices[rayhit.hit.primID * 3]].get();		return intersection;	} else {		return std::nullopt;	}#else	auto best_isect = cr::intersection();	best_isect.distance = std::numeric_limits<float>::infinity();	for (size_t i = 0; i < _indices.size(); i += 3) {		const auto v0 = glm::vec3(						_vertices[_indices[i + 0] * 3 + 0],						_vertices[_indices[i + 0] * 3 + 1],						_vertices[_indices[i + 0] * 3 + 2]);		const auto v1 = glm::vec3(						_vertices[_indices[i + 1] * 3 + 0],						_vertices[_indices[i + 1] * 3 + 1],						_vertices[_indices[i + 1] * 3 + 2]);		const auto v2 = glm::vec3(						_vertices[_indices[i + 2] * 3 + 0],						_vertices[_indices[i + 2] * 3 + 1],						_vertices[_indices[i + 2] * 3 + 2]);		auto isect = cr::intersection();		isect.material = _materials[_material_indices[_indices[i]]].get();		const auto hit = ::intersect_triangle(						ray,						v0,						v1,						v2,						0.0f,						std::numeric_limits<float>::infinity(),						isect.normal,						isect.texcoord,						isect.distance);		if (isect.distance < best_isect.distance && hit)			best_isect = isect;	}	if (best_isect.distance == std::numeric_limits<float>::infinity())		return std::nullopt;	else		return best_isect;#endif}cr::triangular_scene::~triangular_scene() {	rtcReleaseScene(_scene);	rtcReleaseDevice(_device);}