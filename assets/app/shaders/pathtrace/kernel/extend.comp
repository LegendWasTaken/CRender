#version 440

#define INF 1.0 / 0.0
#define FLT_MAX 3.402823466e+38
#define FLT_MIN 1.175494351e-38
#define ELIPSON 0.001

layout (local_size_x = 64, local_size_y = 1) in;

// No worrying about BVH stuff yet... lets just get this working first
struct Ray {
    vec4 origin; // xyz = origin, w = pixel_id
    vec4 direction; // xyz = dir, w = unused
};

struct Intersection {
    vec4 point; // XYZ = Point, W = Distance
    vec4 normal; // XYZ = Normal, W = Material_ID (int)
};

struct Triangle
{
/*
v0 - X-Z = Vertex 0 XYZ, W = Unused
v1 - X-Z = Vertex 1 XYZ, W = Unused
v2 - X-Z = Vertex 2 XYZ, W = MaterialID (as int)
*/
    vec4 v0;
    vec4 v1;
    vec4 v2;
};
int triangle_mat_id(Triangle triangle) { return floatBitsToInt(triangle.v2.w); }

/* Uniform Structs */
struct Bvh
{
    vec4 front;// X-Z = Minimum X/Z, W = Primitive count - 0 if not leaf
    vec4 back;// X-Z = Maximum X/Z, W = Next node (Or primitive ID) (int bits)
};
vec3 bvh_min(Bvh b) { return b.front.xyz; }
vec3 bvh_max(Bvh b) { return b.back.xyz; }
int bvh_next_node(Bvh b) { return floatBitsToInt(b.back.w); }
int bvh_primitive_id(Bvh b) { return floatBitsToInt(b.back.w); }
int bvh_primitive_count(Bvh b) { return floatBitsToInt(b.front.w); }
bool bvh_is_leaf(Bvh b) { return bool(bvh_primitive_count(b)); }

layout (std430, binding = 0) buffer RayBuffer {
    Ray rays[];
};

layout (std430, binding = 1) buffer IntersectionBuffer {
    Intersection intersections[];
};

layout (std430, binding = 2) buffer BvhBuffer {
    Bvh nodes [];
};

layout (std140, binding = 3) buffer TriangleBuffer {
    Triangle triangles[];
};

layout (location = 0) uniform uint ray_count;

float component_max(vec3 v) {
    return max(max(v.x, v.y), v.z);
}

float component_min(vec3 v) {
    return min(min(v.x, v.y), v.z);
}

bool intersect_aabb(vec3 bmin, vec3 bmax, vec3 o, vec3 id, float max_t, out float distance)
{
    vec3 tmin = (bmin - o) * id;
    vec3 tmax = (bmax - o) * id;

    vec3 t1 = min(tmin, tmax);
    vec3 t2 = max(tmin, tmax);

    float val = max(component_max(t1), 0);

    distance = val;
    return val <= min(component_min(t2), max_t);
}

bool intersect_triangle(Ray r, int prim_id, out Intersection record)
{
    vec3 v0 = triangles[prim_id].v0.xyz;
    vec3 v1 = triangles[prim_id].v1.xyz;
    vec3 v2 = triangles[prim_id].v2.xyz;

    vec3 e0 = v1 - v0;
    vec3 e1 = v2 - v0;
    vec3 n  = cross(e0,e1);

    float t       = dot(v0 - r.origin.xyz, n) / dot(r.direction.xyz, n);
    vec3 p        = r.origin.xyz + t * r.direction.xyz;
    vec3 p0       = p - v0;
    vec2 b        = vec2(dot(p0, e0), dot(p0, e1));
    mat2 A_adj    = mat2(dot(e1, e1), -dot(e0, e1), -dot(e0, e1), dot(e0, e0));
    float inv_det = 1.0/(A_adj[0][0]*A_adj[1][1]-A_adj[0][1]*A_adj[1][0]);
    vec2 uv       = inv_det * (A_adj * b);
    bool isect    = 0.0 < t && t < INF && 0 < uv.x && 0 < uv.y && uv.x + uv.y < 1;

    record.point.w = t;
    record.normal.xyz = normalize(n);
    record.point.xyz = p;

    return isect;
}

bool intersect_ray(Ray ray, out Intersection record, out float traversed)
{
    vec3 inv_dir = vec3(1.0) / ray.direction.xyz;
    uint[64] stack;
    Bvh root = nodes[0];

    uint stack_size = 0;
    uint top = bvh_primitive_count(root) > 0 ? ~0 : bvh_next_node(root);

    Intersection best;
    best.point.w = INF;

    int total = 0;
    while (true)
    {
        if ((top & uint(0x80000000)) != 0) {
            Bvh leaf = nodes[~top];
            int first = bvh_primitive_id(leaf);
            int tri_count = bvh_primitive_count(leaf);
            for (int i = first; i < tri_count + first; ++i)
            {
                Intersection temp;
                if (intersect_triangle(ray, i, temp) && temp.point.w < best.point.w)
                best = temp;
            }
        } else {
            Bvh left = nodes[top];
            Bvh right = nodes[top + 1];
            total += 2;

            float dist_left;
            bool hit_left = intersect_aabb(
                bvh_min(left),
                bvh_max(left),
                ray.origin.xyz, inv_dir,
                best.point.w,
                dist_left);

            float dist_right;
            bool hit_right = intersect_aabb(
                bvh_min(right),
                bvh_max(right),
                ray.origin.xyz, inv_dir,
                best.point.w,
                dist_right);

            uint first = bvh_primitive_count(left) > 0 ? ~top : bvh_next_node(left);
            uint second = bvh_primitive_count(right) > 0 ? ~(top + 1) : bvh_next_node(right);

            if (hit_left)
            {
                if (hit_right)
                {
                    if (dist_left > dist_right)
                    {
                        uint tmp = first;
                        first = second;
                        second = tmp;
                    }
                    stack[stack_size++] = second;
                }
                top = first;
                continue;
            }
            else if (hit_right)
            {
                top = second;
                continue;
            }
        }
        if (stack_size == 0)
            break;

        top = stack[--stack_size];
    }
    record = best;
    traversed = total;
    return best.point.w != INF;
}

void main()
{
    uint idx = gl_GlobalInvocationID.x;

    if (idx >= ray_count) return;

    Ray ray = rays[idx];

    Intersection intersection;
    intersection.point.w = INF;
    float total = 0.0;
    Intersection temp;
    if (nodes.length() > 0 && intersect_ray(ray, temp, total))
    {
        intersection = temp;
        if (dot(intersection.normal.xyz, ray.direction.xyz) > 0)
            intersection.normal *= -1;
    }

    intersections[idx] = intersection;
}
